#summary Performance results of early prefetching implementation
#labels tests,results,openoffice,prefetching,blktrace

= Introduction =
These are the results of early implementation of prefetching module. The aim of these tests is to identify strengths and weaknesses of this approach and draw conclusions on subsequent work.

== Test 1 ==
This test purpose is to check if prefetch tracing works well and why results with prefetching module enabled are the same as without prefetching module.

The test was done using prefetching module running in parallel to blktrace, which records IOs.

=== Test description ===
Test machine: [TestMachineKL1 KL1]

Test environment: 
  * [KubuntuGutsyKL1 Kubuntu Gutsy KL1] with updates as of 2006-06-10.
  * Standard desktop environment.
  * blktrace using network to send trace to other machine
  * prefetch module with async prefetching

Test preparation: 
  * first run to get the trace in prefetching module

Measurements repeatability:
  * 5 runs of OpenOffice, second run analyzed as first run was to get trace for prefetching module
  * each OpenOffice run with drop_caches=3 

Tools:
   * blktrace to get trace of IO activity
   * e2block2file to transform IO trace (sectors accesses) into inode numbers + offsets
   * dump of prefetch trace contents (using /proc/prefetch)
   * [http://prefetch.googlecode.com/svn/trunk/tools/compare-blktrace-with-prefetch-trace.py script] to merge results of IO trace, e2block2file map and prefetch trace into one trace

Raw results are at: 
http://prefetch.googlecode.com/svn/trunk/results/openoffice/prefetching/testmachine-kl1/test-1-prefetching-with-blktrace/
  * hda1.blktrace-**.0.bz2 files are blktrace traces 
  * prefetch-trace-** files are results of cat /proc/prefetch after openoffice is run. 
  * openoffice_times.txt.bz2 is timing of startup along with io ticks and  /proc/pid/stat line 
  * blktrace-prefetch-comparison-20070702-11:52:15.txt.bz2 a result of merge of second run of OpenOffice startup using  compare-blktrace-with-prefetch-trace.py 

Merged file shows for each read request noticed by blktrace the following values: 
  * timestamp relative to first request 
  * disk sector 
  * block number (sector relative to partition start) 
  * application binary name (first few letters) 
  * inode number 
  * offset in inode 
  * whether sector was found in prefetch trace: 
    * found_in_prefetch - found 
    * missing_in_prefetch - not found 
    * indirect_block - block is indirect block 
  * filename (as found by e2block2file) 
 
Examples: 
{{{
0.038841783 4036752 4036815 measure_openoff 242669 6 found_in_prefetch  /lib/tls/i686/cmov/librt-2.5.so 
Cannot find inode, sector=1049272 block=1049335 program=measure_openoff 
0.049870767 1902256 1902319 measure_openoff 67263 0 missing_in_prefetch /usr/share/zoneinfo 
}}}
 
=== Conclusions ===
  # Prefetch tracing does not notice directory reads (which is not surprising, as they are not in pagecache) 
  # Prefetch tracing misses some small files, apparently they are evicted from cache pretty quickly or inodes are discarded. 
  # Prefetch tracing misses some accesses to libraries (but not other  accesses) and some accesses to big files (for example splash image) -  this is pretty surprising, but it might be the same problem as with small files, the pages might be used only once for initialization and  discarded afterwards. 
  # OpenOffice is using its own manually crafted prefetch scheme using "pagein" application which pulls into memory libraries upon OpenOffice start.

== Test 2 ==
This test purpose is to check if prefetch tracing works (by disabling OpenOffice own prefetching), whether async or sync mode is better and what is the impact of dropping directory metadata versus dropping page contents.

=== Test description ===
Test machine: [TestMachineKL1 KL1]

Test environment: 
  * [KubuntuGutsyKL1 Kubuntu Gutsy KL1] with updates as of 2006-06-10.
  * Standard desktop environment.
  * prefetch module with async/sync prefetching
  * drop_caches values: 1 2 3

Test preparation: 
  * None

Measurements repeatability:
  * 5 runs of OpenOffice with each set of options

=== Test results ===
Synchronous prefetching:
|| drop_caches || 3 (drop all) || 2 (drop dentries/inodes) || 1 (drop pagecache) ||
|| Average time (s)  || 10.7796	|| 7.4506	|| 9.2878|| 
|| Standard deviation|| 0.1285	|| 0.0370	|| 0.0319|| 

Asynchronous prefetching:
|| drop_caches || 3 (drop all) || 2 (drop dentries/inodes) || 1 (drop pagecache) ||
|| Average time (s)  || 11.6138	|| 7.6192 	|| 10.1604 || 
|| Standard deviation|| 0.1530	|| 0.0478	|| 0.0361 || 

Raw results are at: 
http://prefetch.googlecode.com/svn/trunk/results/openoffice/prefetching/testmachine-kl1/test-2-prefetching-no-pagein/
 
=== Conclusions ===
  # Synchronous prefetching performs better (at least for OpenOffice pattern). This is consistent with experiences of other prefetching implementations (for example Ubuntu readahead) - fetching all necessary data before starting application makes it run faster than doing prefetching in parallel with execution.
  # Caching pages is more effective than caching metadata (dentries/inodes), but even dentries and inodes are responsible for much slowdown in startup - the warm startup is ~4.5s while startup with dropped dentries and inodes is ~7.5s.
  # By prefetching dentries/inodes we can gain ~1.5 second (10.77s vs 9.28s).
  # Prefetching in this way seems not to be able to cut down startup time below ~9second, even with prefetching inodes/dentries. There seems to be other blocking part - either the layout on disk does not allow data to be read faster (or some IO limitations), there is some bottleneck in kernel, missed accesses in tracing affect the prefetching significantly or prefetching scheme is inefficient.
  # Current prefetching implementation, in lack of OpenOffice prefetching, gives almost 2 seconds gain (10.77s vs 12.98s) and is slightly better than OpenOffice hand-crafted prefetching (11.20s), but without need for manual configuration of prefetching.

== Test 3 ==
This test purpose is to check the startup time of OpenOffice with pagein (OpenOffice own hand-crafted prefetching tool) disabled on generic and custom kernel, for comparisons with prefetching results.

=== Test description ===
Test machine: [TestMachineKL1 KL1]

Test environment: 
  * [KubuntuGutsyKL1 Kubuntu Gutsy KL1] with updates as of 2006-06-10.
  * Standard desktop environment.
  * Custom kernel prefetch module with prefetching and tracing disabled or standard Ubuntu Gutsy kernel (2.6.22-6.13)

Test preparation: 
  * None

Measurements repeatability:
  * 4 runs of OpenOffice, before each run drop_caches was set to 3

=== Test results ===
|| || Custom kernel with prefetching || Standard kernel || 
|| Average time (s)  || 12.9867 || 13.0978 || 
|| Standard deviation|| 0.2164  || 0.0448 || 

Raw results are at: 
http://prefetch.googlecode.com/svn/trunk/results/openoffice/prefetching/testmachine-kl1/test-3-openoffice-no-pagein/
 
=== Conclusions ===
  # OpenOffice startup on custom kernel is comparable to generic kernel and is ~13 seconds.
  # OpenOffice own prefetching has a gain of almost 2 seconds (11.2s vs 13.1s) 

== Test 4 ==
This test purpose is to check if performing pages scan with smaller intervals gives better resolution of trace and how it affects performance of prefetching.

=== Test description ===
Test machine: [TestMachineKL1 KL1]

Test environment: 
  * [KubuntuGutsyKL1 Kubuntu Gutsy KL1] with updates as of 2006-06-10.
  * Standard desktop environment.
  * Custom kernel prefetch module with tracing at 2 second intervals for a total of 12 seconds of tracing.
  * Sync and async prefetching mode tested.

Test preparation: 
  * One run of OpenOffice to generate initial trace.

Measurements repeatability:
  * 5 runs of OpenOffice, before each run drop_caches was set to 3

=== Test results ===
|| || Sync || Async || 
|| Average time (s)  || 10.6218 || 11.2800 || 
|| Standard deviation|| 0.1075 || 0.4108 || 

Raw results are at: 
http://prefetch.googlecode.com/svn/trunk/results/openoffice/prefetching/testmachine-kl1/test-4-tracing-intervals/
 
=== Conclusions ===
  # Greater resolution gives slight decrease of startup time (10.62s vs 10.77s for sync, 11.28s vs 11.61s for async), but it is in in error margin.